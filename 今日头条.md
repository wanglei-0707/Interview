## 今日头条
### 一面 5.5 1小时9分钟

1. 自我介绍
2. 为什么学习前端
3. 介绍一个项目
4. 怎么抽象、拆分一个组件
5. 前端模块化的理解
6. 你了解的前端模块化的方案，他们有什么区别
7. 项目中遇到的问题
8. vuex设计的原理
9. 谈一下对MVVM的理解
10. vue的双向绑定怎么实现的(Object.defineProperty是ES5提出的)
11. 项目中最大的收益是什么
12. 除了发布订阅模式还了解哪些设计模式
13. 垂直居中解决方案
14. 设置absolute绝对定位之后，top，left是相对于什么位置移动的
15. position的取值和差异
16. 了解BFC吗，讲一下BFC，BFC实际的应用情况
17. js数据类型
18. let，const和var的区别
19. 变量提升是什么
20. js原型的概念
21. 原型继承怎么实现
22. 跨域怎么产生的，同源是指什么，a.com到b.a.com会不会产生跨域(会)，b.a.com能收到a.com的请求吗(可以),跨域是在什么阶段发生的，服务器遭到攻击，是怎么攻击的呢(跨域请求是能达到服务器的，服务器能收到请求，也能返回响应，跨域是在浏览器端处理的)

    注意：同源策略是指 **浏览器** 出于安全考虑，禁止页面获取跨域请求的返回值，这个策略是浏览器的同源策略，也就是说跨域请求是能发到服务器端的，服务器端也能正常接收跨域请求并处理，但是浏览器会判断请求是否是跨域的，
23. 常见的http状态码，302和304，说一下304原理，协商缓存和强缓存，协商缓存会发起请求吗，ETag和Last-Modified的区别，服务器端根据什么生成ETag(实体内容)，命中强缓存返回的状态码是什么，强缓存存在什么地方(硬盘和内存中)
24. 前端安全方面有了解吗
25. 算法：给定一个数组和一个目标数，判断数组中是否存在两个数的和为给定的数。时间和空间复杂度
26. 平时怎么获取前端方面的知识和技术，最近在学习什么前端技术，除了前端还对哪方面感兴趣，你有什么问题

### 二面 5.5 30分钟

1. webpack相关配置和优化, entry, output, publicPath, 需要打包的东西很多，速度很慢，怎么优化？
2. vuex的原理，修改一个功能要同时修改store, mutation, action多个地方很不方便，怎么优化
3. commonJS的模块和ES6的模块有什么区别，如何按需加载模块的一部分

    ES6模块的设计思想是尽量静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块都是只能在运行时确定这些东西。CommonJS模块就是对象，输入时必须查找对象属性。
    ```
    let {stat, exists, readFile} = require('fs');
    ```
    以上代码的实质是整体加载fs模块(即加载fs的所有方法)，然后在使用时用到这3个方法，这种加载称为“运行时加载”。ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式
    ```
    import {stat, exists, readFile} from 'fs';
    ```
    以上代码的实质是从fs模块加载3个方法，其他方法不加载，这种加载称为“编译时加载”，即ES6可以在编译时就完成模块编译，效率要比CommonJS模块的加载方式高。

    ES6模块加载机制与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。CommonJS模块输入的是被输出值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。ES6模块的机制不同，它遇到模块加载命令import时不会去执行模块，只会生成一个动态的只读引用，等到真的需要用到时，再到模块中取值，即原始值变了，输入值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

    CommonJS模块加载原理：require命令第一次加载一个模块时会执行整个脚本，然后在内存中生成一个对象。
    ```
    {
        id: '...', // id属性是模块名
        exports: {...}, // exports属性是模块输出的各个接口
        loaded: true, // loaded属性表示该模块的脚本是否执行完毕
        ...
    }
    ```
    以后需要用到这个模块时，就会到exports属性上取值，即使再次执行require命令，也不会再次执行该模块，而是到缓存中取值。

    CommonJS模块循环加载原理：一旦出现某刻模块被循环加载，就只输出已经执行的部分，还未执行的部分不会输出。

    ES6模块循环加载原理：动态引用，遇到模块加载命令import时不会去执行模块，只是生成一个指向被加载模块的引用。
4. ES6用过哪些特性，用过箭头函数吗，箭头函数和普通函数什么区别，剩余函数和arguments什么区别，arguments为什么是伪数组，伪数组怎么转为数组
5. map和weakmap什么区别，有了object为什么还需要map

    Map结构的目的：object对象本质上是键值对的集合(Hash结构), 但是只能用字符串作为键，这给它带来了很大的限制。为了解决这个问题，ES6引入了Map数据结构，类似于对象，也是键值对的集合，但是键的范围不限于字符串，各种类型的值都可以当做键。
    ```
    var m = new Map();
    var o = {p: 'hello world'};
    m.set(o, 'content');  // set实例方法，设置key对应的键值，返回整个Map结构，因此可以使用链式写法
    m.get(o) // 'content'
    m.has(o) // true
    m.delete(o); // delete实例方法，删除某个键，返回true，如果删除失败，返回false
    m.has(o) // false

    // 构造函数接受一个数组作为参数，数组的成员是一个个表示键值对的数组
    var map = new Map([['name', '张三'], ['title', 'author']]);
    map.size // 2  size实例属性，返回成员总数
    map.has('name') // true
    map.get('name') // '张三'

    // 对同一个键多次赋值，后面的值会覆盖前面的值
    map.set('age', 22).set('age', 30)
    map.get('age') // 30  
    new map().get('name') // undefined 读取一个未知的值，返回undefined

    // 只有对同一个对象的引用，map才将其视为同一个键。如下表面上get和set方法是针对同一个值，但是实际上是两个值，内存地址是不同的
    map.set(['a'], 555)
    map.get(['a']) // undefined

    // 对于简单数据类型，只要值严格相等，map就将其视为一个键，包括0和-0，NaN虽然不严格等于自身，但是map将其视为同一个键
    map.set(NaN, 123)
    map.get(NaN) // 123
    ```
    WeakMap与Map基本类似，唯一区别是它只接受对象作为键名(null除外)，不能接受其他类型的值作为键名，而且键名所指向的对象不计入垃圾回收机制。在API上的区别是WeakMap没有遍历操作，既没有keys(), values(), entries()方法，也没有size实例属性，WeakMap也无法清空，即没有clear()方法，这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get(), set(), has(), delete()。

    WeakMap的设计目的在于，键名是对象的弱引用(垃圾回收机制不将该引用考虑在内)，所以其所对应的对象可能会被自动回收，当对象被回收后，WeakMap自动移除对应的键值对。典型应用是一个对应DOM元素的Map结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。WeakMap专用场合就是它的键所对应的对象可能会在将来消失。WeakMap有助于防止内存泄露。
6. 前端跨域，不同请求需要服务器返回不同结果，怎么解决(正反代理)

    参考博客：[图解正向代理、反向代理、透明代理](http://z00w00.blog.51cto.com/515114/1031287)
7. vue更新渲染原理，一个虚拟DOM对象实质上没有发生改变，但是判断两个是否相等时结果是false，怎么解决
8. Vue和React区别，Vuex和Redux区别
9. 函数式编程
(还有一些不记得了)
