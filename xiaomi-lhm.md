# 小米-芦荟
## 算法
1. 快排的思想和复杂度

    快速排序选择分治的思想，把一个串分为两个子串。首相选择一个数作为基数，然后遍历剩下所有的数，将小于基数的放在左边，大于基数的放在右边，相同的可以放在任一边，这个过程称为分区（partition）操作,然后再递归地分别对左右两边的子串进行排序。

    复杂度：如果枢轴为n/2，则和归并排序的复杂度一样，为O(nlogn)(最好),如果每次划分后枢轴为0或最后一个，则出现最差情况，时间复杂度为O(n^2).平均复杂度为O(nlogn).
2. 二分查找的思想和复杂度，快排和二分的思想叫什么？面试官提示是分治。

    二分查找也是用分治的思想，查找的序列需是排好序的，每次查看中间的数，比较是否是查找的数，如果不是再递归查找。复杂度为O(logn).

## CSS
1. box-sizing是什么，有什么作用？有哪些值？

    1. content-box:是标准模式，内边距和边框在宽高之外绘制。宽度+padding+border+margin是实际占用的宽。
    2. border-box：是IE盒子模型，内边距和边框在宽高之内绘制。宽度+margin为实际的宽高。
    3. padding-box: 已经被废弃

2. 常见的图片样式有哪些？分别在什么情况下使用
    1. jpg：支持有损压缩，不支持透明，不支持动画，非矢量，色彩还原度比较好，可以支持适当压缩后保持比较好的色彩度。如果颜色很多，建议使用这种图片格式，可以使生成的图片大小比较小而不会使图片看起来很模糊。
    2. jpeg：与jpg类似，支持有陨压缩，不支持透明，不支持动画，非矢量。用一种有损压缩法压缩图片，把人肉眼难以察觉的图象色彩删除，由此来获得比较大的压缩比，所以图片占用空间往往很小，而且“外表”上也看不出有什么差别，但是此格式压缩后的图片无法还原，所以在处理JPEG图片的时候请不要多次反复修改存储，这样的话图象会逐渐恶化。
    3. png：不支持压缩，支持透明、半透明、不透明，不支持动画，非矢量，与GIF格式相似，压缩比高于GIF，能够处理的色数远远多于GIF格式，最大可达280兆色。
    4. gif：支持有陨压缩，不支持全透明，支持半透明，支持动画，非矢量。最大只能够处理256色的图像。其原理也就是把多张图象保存为一个图象从而形成动画，说到底仍然是图片格式（位图）。文件占用空间很小。使用该格式的场景：网页背景、小图标、色彩度低的小切片、动画图片；
3. 什么是margin折叠？

    见整理：[外边距叠加](https://wanglei-0707.github.io/CSS3/margincollapse/index.html)
4. em和rem什么区别
    1. em相对于父元素的字体大小，最多取到小数点的后三位。如果元素自身设置了font-size属性，那么它的其他css属性也是用em单位的话，则是基于自身的字体大小。
    2. rem：1rem 等于 html标签的font-size，如果html标签未设置font-size属性，则等于浏览器默认的字体大小，一般为16px。
    3. vm: 视口（viewport）的宽度的1/100
    4. vh: 视口（viewport）的高度的1/100

## JS
1. 了解作用域链吗？举一个作用域链有2个，3个节点，举一个作用域有无数个节点？

    1. 作用域其实就是函数或变量的使用范围。
        1. 函数作用域：
        2. 块作用域：ES6中提供了块级作用域。注意：try/catch的catch语句也会创建一个块作用域。

    2. 改变函数作用域的方法：
        1. eval()方法: 接受一个字符串作为参数，相当于在eval函数所在位置执行了参数中的代码，在严格模式下，eval会产生自己的作用域。 eval性能消耗很大，也可能带来安全隐患，因此不推荐使用。
    ```
    function foo(str, a){
        'use strict' //严格模式下报错，ReferenceError: b is not defined
        eval(str);
        console.log(a, b); //非严格模式下打印1，2
    }
    foo('var b = 2;', 1);
    ```
        2. with关键字：通常被当作重复引用同一个对象中的多个属性的快捷方式。with也会带来性能的损耗。
    ```
    var obj = {
        a: 1,
        b: 2,
        c: 3
    };
    // 简单的快捷方式
    with (obj) {
        a = 3;
        b = 4;
        c = 5;
    }      
    ```
    3. 声明提升：
        1. 每个作用域都会进行提升操作。声明会被提升到所在作用域的顶部。
        2. 函数声明会被提升，函数表达式不会被提升
        3. 通过var 定义的变量会提升，而let和const进行的声明不会提升。
        4. 函数声明和变量声明都会被提升。但是函数会首先被提升，然后才是变量，也就是说如果一个变量声明和一个函数声明同名，那么就算在语句顺序上变量声明在前，该标识符还是会指向相关函数。
    ```
    console.log(a); //[function:a]
    var a = 1;
    function a(){}
    ```

    4. 闭包：
    有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式是在一个函数中创建另一个函数。
    当一个函数的返回值是另外一个函数，而返回的那个函数如果调用了其父函数内部的其它变量，如果返回的这个函数在外部被执行，就产生了闭包。闭包的使用：
        1. 异步操作中的回调函数
        2. 模块
    ```
    function CoolModule() {        
        var something = "cool";        
        var another = [1, 2, 3];    
        function doSomething() {            
            console.log(something);
        }    
        function doAnother() {            
            console.log(another.join(" ! "));
        }    
        // 返回的是一个对象，对象中可能包含各种函数
        return {
            doSomething: doSomething,
            doAnother: doAnother
        };
    }
    var foo = CoolModule();
    // 在外面调用返回对象中的方法就形成了闭包
    foo.doSomething(); // cool
    foo.doAnother(); // 1 ! 2 ! 3
    ```   
2. 如何实现原型继承？

    sub.prototype = new Super();
3. cookie和localStorage有什么区别？为什么cookie的容量比localStorage少这么多？

    1. cookie机制：
        1. 正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。
        2. cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式。

    2. session机制：
        1. 是一种服务器端的机制当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。
        2. 保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。

    3. cookie 和session 的区别：
        1. cookie数据存放在客户的浏览器上，session数据放在服务器上。
        2. cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
       考虑到安全应当使用session。
       3. session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
       考虑到减轻服务器性能方面，应当使用COOKIE。
       4. 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
       5. 个人建议：将登陆信息等重要信息存放为SESSION,其他信息如果需要保留，可以放在COOKIE中
       6. session保存在服务器，客户端不知道其中的信息；cookie保存在客户端，服务器能够知道其中的信息。   
       7. session中保存的是对象，cookie中保存的是字符串。   
       8. session不能区分路径，同一个用户在访问一个网站期间，所有的session在任何一个地方都可以访问到。而cookie中如果设置了路径参数，那么同一个网站中不同路径下的cookie互相是访问不到的。  

    4. sessionStorage 、localStorage 和 cookie 之间的区别:
        1. 共同点：都是保存在浏览器端，且同源的。
        2. 区别：
            1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。
            2. 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。
            3. 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。
            4. 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。
            5. Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。
            6. Web Storage 的 api 接口使用更方便。
4. 了解事件委托吗？是怎么实现的？捕获和冒泡谁先谁后？在ul下很多li，在ul上实现对li的监听

    1. 事件流：
    事件流描述的是从页面中接收事件的顺序。IE的事件流是事件冒泡流，即事件开始时由最具体的元素开始接收，然后逐级向上传递到较为不具体的节点(文档)(知道window对象)。另一种是事件捕获流，即事件开始时由做不具体的元素开始接收(尽管“DOM2级事件”规范要求事件应该从document对象开始传播，但是浏览器中都是从window对象开始)，而最具体的节点最后接收。

    2. DOM事件流：
    DOM2级事件规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。DOM事件流中规定，实际的目标在捕获阶段不会接收到事件，这意味着，在捕获阶段，事件从document到<html>再到<body>后就停止了。即使DOM2级事件规范明确要求不会阶段不会涉及事件目标，但是大部分浏览器都会在捕获阶段触发事件对象上的事件，结果就是有两个机会在目标元素上操作事件。

    3. 事件处理程序：
        1. HTML事件处理程序：直接在html标签的属性中指定。
    ```
    <input type="button" value="click me" onclick="showMessage()">
    ```
    这种方式指定的事件处理函数通过width扩展了作用域，可以像访问局部变量一样访问document及该元素本身的成员。如果当前元素是一个表单输入元素，作则用于中还包含访问表单元素的入口。此时，可以直接使用其他表单字段的name值访问该表单字段。
    ```
    function(){
        with(document){
            with(this.form){
                with(this){
                    //元素属性值
                }
            }
        }
    }
    ```
    HTML事件处理程序的缺点：1. 存在时差问题，例如给一个按钮绑定了click事件处理程序，但是这个事件处理函数在这个button之后出现，如果用户在页面解析到这个函数之前就点击了这个按钮就会报错。可以通过try/catch捕获。2. 这样扩展事件处理程序的作用域链在不同浏览器中会导致不同的结果。3. 使HTML和JavaScript代码紧密耦合。
        2. DOM0级事件处理程序：
    就是将一个函数赋值给一个事件处理程序属性。这种方式添加的事件处理程序会在事件流的冒泡阶段被处理，函数中的this引用当前元素。删除指定的事件处理程序时将事件处理程序属性设置为null即可。
    ```
    var btn = document.getElementById('btn');
    btn.onclick = function(){
        alert('click me');
    }
    btn.onclick = null;
    ```
    DOM0级事件处理程序的缺点：1. 同HTML事件处理程序缺点1 2.只能指定一个事件处理程序，后面的会覆盖前面的。
        3. DOM2级事件处理程序：
    addEventListener(type, handler, false)第三个参数为false表示在冒泡阶段调用事件处理程序，为true表示在捕获阶段调用事件处理程序。处理程序中的this也是引用当前元素。不DOM0级不同的是DOM2级可以添加多个事件处理程序，当事件发生时按添加的顺序触发。删除时使用removeEventListener(type, handler, false)函数，删除时传入的参数与添加时的参数相同。所以通过addEventListener()添加的匿名函数无法删除。
        4. IE事件处理程序：
    attachEvent(type('on'开头), handler)。与DOM2级事件处理程序的不同：1. 函数中的this引用的是window对象 2. 事件处理程序不是一添加它们的顺序执行，而是以相反的顺序执行。删除时使用detachEvent()。

## 数据库
简历上写了熟悉mysql，就问了。
1. 索引具体怎么实现的，索引是针对行还是列
2. 了解mysql主从同步吗？
